{"ast":null,"code":"import _classCallCheck from \"/Users/kylelong/corkedup/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kylelong/corkedup/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { isNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { getEnterLeaveForKind } from '../language/visitor.mjs';\nimport { getNamedType, getNullableType, isCompositeType, isEnumType, isInputObjectType, isInputType, isInterfaceType, isListType, isObjectType, isOutputType } from '../type/definition.mjs';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection.mjs';\nimport { typeFromAST } from './typeFromAST.mjs';\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema,\n  /**\n   * Initial type may be provided in rare cases to facilitate traversals\n   *  beginning somewhere other than documents.\n   */\n  initialType,\n  /** @deprecated will be removed in 17.0.0 */\n  getFieldDefFn) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  _createClass(TypeInfo, [{\n    key: Symbol.toStringTag,\n    get: function get() {\n      return 'TypeInfo';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      if (this._typeStack.length > 0) {\n        return this._typeStack[this._typeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getParentType\",\n    value: function getParentType() {\n      if (this._parentTypeStack.length > 0) {\n        return this._parentTypeStack[this._parentTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getInputType\",\n    value: function getInputType() {\n      if (this._inputTypeStack.length > 0) {\n        return this._inputTypeStack[this._inputTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getParentInputType\",\n    value: function getParentInputType() {\n      if (this._inputTypeStack.length > 1) {\n        return this._inputTypeStack[this._inputTypeStack.length - 2];\n      }\n    }\n  }, {\n    key: \"getFieldDef\",\n    value: function getFieldDef() {\n      if (this._fieldDefStack.length > 0) {\n        return this._fieldDefStack[this._fieldDefStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getDefaultValue\",\n    value: function getDefaultValue() {\n      if (this._defaultValueStack.length > 0) {\n        return this._defaultValueStack[this._defaultValueStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getDirective\",\n    value: function getDirective() {\n      return this._directive;\n    }\n  }, {\n    key: \"getArgument\",\n    value: function getArgument() {\n      return this._argument;\n    }\n  }, {\n    key: \"getEnumValue\",\n    value: function getEnumValue() {\n      return this._enumValue;\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(node) {\n      var schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n      // any assumptions of a valid schema to ensure runtime types are properly\n      // checked before continuing since TypeInfo is used as part of validation\n      // which occurs before guarantees of schema and document validity.\n\n      switch (node.kind) {\n        case Kind.SELECTION_SET:\n          {\n            var namedType = getNamedType(this.getType());\n\n            this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n            break;\n          }\n\n        case Kind.FIELD:\n          {\n            var parentType = this.getParentType();\n            var fieldDef;\n            var fieldType;\n\n            if (parentType) {\n              fieldDef = this._getFieldDef(schema, parentType, node);\n\n              if (fieldDef) {\n                fieldType = fieldDef.type;\n              }\n            }\n\n            this._fieldDefStack.push(fieldDef);\n\n            this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n            break;\n          }\n\n        case Kind.DIRECTIVE:\n          this._directive = schema.getDirective(node.name.value);\n          break;\n\n        case Kind.OPERATION_DEFINITION:\n          {\n            var rootType = schema.getRootType(node.operation);\n\n            this._typeStack.push(isObjectType(rootType) ? rootType : undefined);\n\n            break;\n          }\n\n        case Kind.INLINE_FRAGMENT:\n        case Kind.FRAGMENT_DEFINITION:\n          {\n            var typeConditionAST = node.typeCondition;\n            var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n            this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n            break;\n          }\n\n        case Kind.VARIABLE_DEFINITION:\n          {\n            var inputType = typeFromAST(schema, node.type);\n\n            this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n            break;\n          }\n\n        case Kind.ARGUMENT:\n          {\n            var _this$getDirective;\n\n            var argDef;\n            var argType;\n            var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n            if (fieldOrDirective) {\n              argDef = fieldOrDirective.args.find(function (arg) {\n                return arg.name === node.name.value;\n              });\n\n              if (argDef) {\n                argType = argDef.type;\n              }\n            }\n\n            this._argument = argDef;\n\n            this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n            this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n            break;\n          }\n\n        case Kind.LIST:\n          {\n            var listType = getNullableType(this.getInputType());\n            var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n            this._defaultValueStack.push(undefined);\n\n            this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n            break;\n          }\n\n        case Kind.OBJECT_FIELD:\n          {\n            var objectType = getNamedType(this.getInputType());\n            var inputFieldType;\n            var inputField;\n\n            if (isInputObjectType(objectType)) {\n              inputField = objectType.getFields()[node.name.value];\n\n              if (inputField) {\n                inputFieldType = inputField.type;\n              }\n            }\n\n            this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n            this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n            break;\n          }\n\n        case Kind.ENUM:\n          {\n            var enumType = getNamedType(this.getInputType());\n            var enumValue;\n\n            if (isEnumType(enumType)) {\n              enumValue = enumType.getValue(node.value);\n            }\n\n            this._enumValue = enumValue;\n            break;\n          }\n\n        default: // Ignore other nodes\n\n      }\n    }\n  }, {\n    key: \"leave\",\n    value: function leave(node) {\n      switch (node.kind) {\n        case Kind.SELECTION_SET:\n          this._parentTypeStack.pop();\n\n          break;\n\n        case Kind.FIELD:\n          this._fieldDefStack.pop();\n\n          this._typeStack.pop();\n\n          break;\n\n        case Kind.DIRECTIVE:\n          this._directive = null;\n          break;\n\n        case Kind.OPERATION_DEFINITION:\n        case Kind.INLINE_FRAGMENT:\n        case Kind.FRAGMENT_DEFINITION:\n          this._typeStack.pop();\n\n          break;\n\n        case Kind.VARIABLE_DEFINITION:\n          this._inputTypeStack.pop();\n\n          break;\n\n        case Kind.ARGUMENT:\n          this._argument = null;\n\n          this._defaultValueStack.pop();\n\n          this._inputTypeStack.pop();\n\n          break;\n\n        case Kind.LIST:\n        case Kind.OBJECT_FIELD:\n          this._defaultValueStack.pop();\n\n          this._inputTypeStack.pop();\n\n          break;\n\n        case Kind.ENUM:\n          this._enumValue = null;\n          break;\n\n        default: // Ignore other nodes\n\n      }\n    }\n  }]);\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var node = args[0];\n      typeInfo.enter(node);\n      var fn = getEnterLeaveForKind(visitor, node.kind).enter;\n\n      if (fn) {\n        var result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var node = args[0];\n      var fn = getEnterLeaveForKind(visitor, node.kind).leave;\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}","map":{"version":3,"sources":["/Users/kylelong/corkedup/client/node_modules/graphql/utilities/TypeInfo.mjs"],"names":["isNode","Kind","getEnterLeaveForKind","getNamedType","getNullableType","isCompositeType","isEnumType","isInputObjectType","isInputType","isInterfaceType","isListType","isObjectType","isOutputType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","TypeInfo","schema","initialType","getFieldDefFn","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","Symbol","toStringTag","length","node","kind","SELECTION_SET","namedType","getType","undefined","FIELD","parentType","getParentType","fieldDef","fieldType","type","DIRECTIVE","getDirective","name","value","OPERATION_DEFINITION","rootType","getRootType","operation","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","_this$getDirective","argDef","argType","fieldOrDirective","args","find","arg","defaultValue","LIST","listType","getInputType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","pop","fieldNode","getQueryType","visitWithTypeInfo","typeInfo","visitor","enter","fn","result","apply","leave"],"mappings":"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","sourcesContent":["import { isNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { getEnterLeaveForKind } from '../language/visitor.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isCompositeType,\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isListType,\n  isObjectType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { typeFromAST } from './typeFromAST.mjs';\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport class TypeInfo {\n  constructor(\n    schema,\n    /**\n     * Initial type may be provided in rare cases to facilitate traversals\n     *  beginning somewhere other than documents.\n     */\n    initialType,\n    /** @deprecated will be removed in 17.0.0 */\n    getFieldDefFn,\n  ) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef =\n      getFieldDefFn !== null && getFieldDefFn !== void 0\n        ? getFieldDefFn\n        : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n\n  getDirective() {\n    return this._directive;\n  }\n\n  getArgument() {\n    return this._argument;\n  }\n\n  getEnumValue() {\n    return this._enumValue;\n  }\n\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET: {\n        const namedType = getNamedType(this.getType());\n\n        this._parentTypeStack.push(\n          isCompositeType(namedType) ? namedType : undefined,\n        );\n\n        break;\n      }\n\n      case Kind.FIELD: {\n        const parentType = this.getParentType();\n        let fieldDef;\n        let fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n        break;\n      }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION: {\n        const rootType = schema.getRootType(node.operation);\n\n        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION: {\n        const typeConditionAST = node.typeCondition;\n        const outputType = typeConditionAST\n          ? typeFromAST(schema, typeConditionAST)\n          : getNamedType(this.getType());\n\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n        break;\n      }\n\n      case Kind.VARIABLE_DEFINITION: {\n        const inputType = typeFromAST(schema, node.type);\n\n        this._inputTypeStack.push(\n          isInputType(inputType) ? inputType : undefined,\n        );\n\n        break;\n      }\n\n      case Kind.ARGUMENT: {\n        var _this$getDirective;\n\n        let argDef;\n        let argType;\n        const fieldOrDirective =\n          (_this$getDirective = this.getDirective()) !== null &&\n          _this$getDirective !== void 0\n            ? _this$getDirective\n            : this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = fieldOrDirective.args.find(\n            (arg) => arg.name === node.name.value,\n          );\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n        break;\n      }\n\n      case Kind.LIST: {\n        const listType = getNullableType(this.getInputType());\n        const itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n        break;\n      }\n\n      case Kind.OBJECT_FIELD: {\n        const objectType = getNamedType(this.getInputType());\n        let inputFieldType;\n        let inputField;\n\n        if (isInputObjectType(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(\n          inputField ? inputField.defaultValue : undefined,\n        );\n\n        this._inputTypeStack.push(\n          isInputType(inputFieldType) ? inputFieldType : undefined,\n        );\n\n        break;\n      }\n\n      case Kind.ENUM: {\n        const enumType = getNamedType(this.getInputType());\n        let enumValue;\n\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n      }\n\n      default: // Ignore other nodes\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n\n      default: // Ignore other nodes\n    }\n  }\n}\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n\n  if (\n    name === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(...args) {\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = getEnterLeaveForKind(visitor, node.kind).enter;\n\n      if (fn) {\n        const result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave(...args) {\n      const node = args[0];\n      const fn = getEnterLeaveForKind(visitor, node.kind).leave;\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}