{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar helpers = require('./helpers');\n\nvar Parser = require('./parser');\n\nvar request = require('request');\n\nvar STATUS_CODES_TO_ABORT_ON = require('./settings').STATUS_CODES_TO_ABORT_ON;\n\nvar StreamingAPIConnection = function (reqOpts, twitOptions) {\n  this.reqOpts = reqOpts;\n  this.twitOptions = twitOptions;\n  this._twitter_time_minus_local_time_ms = 0;\n  EventEmitter.call(this);\n};\n\nutil.inherits(StreamingAPIConnection, EventEmitter);\n/**\n * Resets the connection.\n * - clears request, response, parser\n * - removes scheduled reconnect handle (if one was scheduled)\n * - stops the stall abort timeout handle (if one was scheduled)\n */\n\nStreamingAPIConnection.prototype._resetConnection = function () {\n  if (this.request) {\n    // clear our reference to the `request` instance\n    this.request.removeAllListeners();\n    this.request.destroy();\n  }\n\n  if (this.response) {\n    // clear our reference to the http.IncomingMessage instance\n    this.response.removeAllListeners();\n    this.response.destroy();\n  }\n\n  if (this.parser) {\n    this.parser.removeAllListeners();\n  } // ensure a scheduled reconnect does not occur (if one was scheduled)\n  // this can happen if we get a close event before .stop() is called\n\n\n  clearTimeout(this._scheduledReconnect);\n  delete this._scheduledReconnect; // clear our stall abort timeout\n\n  this._stopStallAbortTimeout();\n};\n/**\n * Resets the parameters used in determining the next reconnect time\n */\n\n\nStreamingAPIConnection.prototype._resetRetryParams = function () {\n  // delay for next reconnection attempt\n  this._connectInterval = 0; // flag indicating whether we used a 0-delay reconnect\n\n  this._usedFirstReconnect = false;\n};\n\nStreamingAPIConnection.prototype._startPersistentConnection = function () {\n  var self = this;\n\n  self._resetConnection();\n\n  self._setupParser();\n\n  self._resetStallAbortTimeout();\n\n  self._setOauthTimestamp();\n\n  this.reqOpts.encoding = 'utf8';\n  self.request = request.post(this.reqOpts);\n  self.emit('connect', self.request);\n  self.request.on('response', function (response) {\n    self._updateOauthTimestampOffsetFromResponse(response); // reset our reconnection attempt flag so next attempt goes through with 0 delay\n    // if we get a transport-level error\n\n\n    self._usedFirstReconnect = false; // start a stall abort timeout handle\n\n    self._resetStallAbortTimeout();\n\n    self.response = response;\n\n    if (STATUS_CODES_TO_ABORT_ON.indexOf(self.response.statusCode) !== -1) {\n      // We got a status code telling us we should abort the connection.\n      // Read the body from the response and return an error to the user.\n      var body = '';\n      self.request.on('data', function (chunk) {\n        body += chunk;\n      });\n      self.request.on('end', function () {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {// Twitter may send an HTML body\n          // if non-JSON text was returned, we'll just attach it to the error as-is\n        } // surface the error to the user\n\n\n        var error = helpers.makeTwitError('Bad Twitter streaming request: ' + self.response.statusCode);\n        error.statusCode = response ? response.statusCode : null;\n        helpers.attachBodyInfoToError(error, body);\n        self.emit('error', error); // stop the stream explicitly so we don't reconnect\n\n        self.stop();\n        body = null;\n      });\n      self.request.on('error', function (err) {\n        var twitErr = helpers.makeTwitError(err.message);\n        twitErr.statusCode = self.response.statusCode;\n        helpers.attachBodyInfoToError(twitErr, body);\n        self.emit('parser-error', twitErr);\n      });\n    } else if (self.response.statusCode === 420) {\n      // close the connection forcibly so a reconnect is scheduled by `self.onClose()`\n      self._scheduleReconnect();\n    } else {\n      // We got an OK status code - the response should be valid.\n      // Read the body from the response and return to the user.\n      //pass all response data to parser\n      self.request.on('data', function (data) {\n        self._connectInterval = 0;\n\n        self._resetStallAbortTimeout();\n\n        self.parser.parse(data);\n      });\n      self.response.on('close', self._onClose.bind(self));\n      self.response.on('error', function (err) {\n        // expose response errors on twit instance\n        self.emit('error', err);\n      }); // connected without an error response from Twitter, emit `connected` event\n      // this must be emitted after all its event handlers are bound\n      // so the reference to `self.response` is not interfered-with by the user until it is emitted\n\n      self.emit('connected', self.response);\n    }\n  });\n  self.request.on('close', self._onClose.bind(self));\n  self.request.on('error', function (err) {\n    self._scheduleReconnect.bind(self);\n  });\n  return self;\n};\n/**\n * Handle when the request or response closes.\n * Schedule a reconnect according to Twitter's reconnect guidelines\n *\n */\n\n\nStreamingAPIConnection.prototype._onClose = function () {\n  var self = this;\n\n  self._stopStallAbortTimeout();\n\n  if (self._scheduledReconnect) {\n    // if we already have a reconnect scheduled, don't schedule another one.\n    // this race condition can happen if the http.ClientRequest and http.IncomingMessage both emit `close`\n    return;\n  }\n\n  self._scheduleReconnect();\n};\n/**\n * Kick off the http request, and persist the connection\n *\n */\n\n\nStreamingAPIConnection.prototype.start = function () {\n  this._resetRetryParams();\n\n  this._startPersistentConnection();\n\n  return this;\n};\n/**\n * Abort the http request, stop scheduled reconnect (if one was scheduled) and clear state\n *\n */\n\n\nStreamingAPIConnection.prototype.stop = function () {\n  // clear connection variables and timeout handles\n  this._resetConnection();\n\n  this._resetRetryParams();\n\n  return this;\n};\n/**\n * Stop and restart the stall abort timer (called when new data is received)\n *\n * If we go 90s without receiving data from twitter, we abort the request & reconnect.\n */\n\n\nStreamingAPIConnection.prototype._resetStallAbortTimeout = function () {\n  var self = this; // stop the previous stall abort timer\n\n  self._stopStallAbortTimeout(); //start a new 90s timeout to trigger a close & reconnect if no data received\n\n\n  self._stallAbortTimeout = setTimeout(function () {\n    self._scheduleReconnect();\n  }, 90000);\n  return this;\n};\n/**\n * Stop stall timeout\n *\n */\n\n\nStreamingAPIConnection.prototype._stopStallAbortTimeout = function () {\n  clearTimeout(this._stallAbortTimeout); // mark the timer as `null` so it is clear via introspection that the timeout is not scheduled\n\n  delete this._stallAbortTimeout;\n  return this;\n};\n/**\n * Computes the next time a reconnect should occur (based on the last HTTP response received)\n * and starts a timeout handle to begin reconnecting after `self._connectInterval` passes.\n *\n * @return {Undefined}\n */\n\n\nStreamingAPIConnection.prototype._scheduleReconnect = function () {\n  var self = this;\n\n  if (self.response && self.response.statusCode === 420) {\n    // we are being rate limited\n    // start with a 1 minute wait and double each attempt\n    if (!self._connectInterval) {\n      self._connectInterval = 60000;\n    } else {\n      self._connectInterval *= 2;\n    }\n  } else if (self.response && String(self.response.statusCode).charAt(0) === '5') {\n    // twitter 5xx errors\n    // start with a 5s wait, double each attempt up to 320s\n    if (!self._connectInterval) {\n      self._connectInterval = 5000;\n    } else if (self._connectInterval < 320000) {\n      self._connectInterval *= 2;\n    } else {\n      self._connectInterval = 320000;\n    }\n  } else {\n    // we did not get an HTTP response from our last connection attempt.\n    // DNS/TCP error, or a stall in the stream (and stall timer closed the connection)\n    if (!self._usedFirstReconnect) {\n      // first reconnection attempt on a valid connection should occur immediately\n      self._connectInterval = 0;\n      self._usedFirstReconnect = true;\n    } else if (self._connectInterval < 16000) {\n      // linearly increase delay by 250ms up to 16s\n      self._connectInterval += 250;\n    } else {\n      // cap out reconnect interval at 16s\n      self._connectInterval = 16000;\n    }\n  } // schedule the reconnect\n\n\n  self._scheduledReconnect = setTimeout(function () {\n    self._startPersistentConnection();\n  }, self._connectInterval);\n  self.emit('reconnect', self.request, self.response, self._connectInterval);\n};\n\nStreamingAPIConnection.prototype._setupParser = function () {\n  var self = this;\n  self.parser = new Parser(); // handle twitter objects as they come in - emit the generic `message` event\n  // along with the specific event corresponding to the message\n\n  self.parser.on('element', function (msg) {\n    self.emit('message', msg);\n\n    if (msg.delete) {\n      self.emit('delete', msg);\n    } else if (msg.disconnect) {\n      self._handleDisconnect(msg);\n    } else if (msg.limit) {\n      self.emit('limit', msg);\n    } else if (msg.scrub_geo) {\n      self.emit('scrub_geo', msg);\n    } else if (msg.warning) {\n      self.emit('warning', msg);\n    } else if (msg.status_withheld) {\n      self.emit('status_withheld', msg);\n    } else if (msg.user_withheld) {\n      self.emit('user_withheld', msg);\n    } else if (msg.friends || msg.friends_str) {\n      self.emit('friends', msg);\n    } else if (msg.direct_message) {\n      self.emit('direct_message', msg);\n    } else if (msg.event) {\n      self.emit('user_event', msg); // reference: https://dev.twitter.com/docs/streaming-apis/messages#User_stream_messages\n\n      var ev = msg.event;\n\n      if (ev === 'blocked') {\n        self.emit('blocked', msg);\n      } else if (ev === 'unblocked') {\n        self.emit('unblocked', msg);\n      } else if (ev === 'favorite') {\n        self.emit('favorite', msg);\n      } else if (ev === 'unfavorite') {\n        self.emit('unfavorite', msg);\n      } else if (ev === 'follow') {\n        self.emit('follow', msg);\n      } else if (ev === 'unfollow') {\n        self.emit('unfollow', msg);\n      } else if (ev === 'mute') {\n        self.emit('mute', msg);\n      } else if (ev === 'unmute') {\n        self.emit('unmute', msg);\n      } else if (ev === 'user_update') {\n        self.emit('user_update', msg);\n      } else if (ev === 'list_created') {\n        self.emit('list_created', msg);\n      } else if (ev === 'list_destroyed') {\n        self.emit('list_destroyed', msg);\n      } else if (ev === 'list_updated') {\n        self.emit('list_updated', msg);\n      } else if (ev === 'list_member_added') {\n        self.emit('list_member_added', msg);\n      } else if (ev === 'list_member_removed') {\n        self.emit('list_member_removed', msg);\n      } else if (ev === 'list_user_subscribed') {\n        self.emit('list_user_subscribed', msg);\n      } else if (ev === 'list_user_unsubscribed') {\n        self.emit('list_user_unsubscribed', msg);\n      } else if (ev === 'quoted_tweet') {\n        self.emit('quoted_tweet', msg);\n      } else if (ev === 'favorited_retweet') {\n        self.emit('favorited_retweet', msg);\n      } else if (ev === 'retweeted_retweet') {\n        self.emit('retweeted_retweet', msg);\n      } else {\n        self.emit('unknown_user_event', msg);\n      }\n    } else {\n      self.emit('tweet', msg);\n    }\n  });\n  self.parser.on('error', function (err) {\n    self.emit('parser-error', err);\n  });\n  self.parser.on('connection-limit-exceeded', function (err) {\n    self.emit('error', err);\n  });\n};\n\nStreamingAPIConnection.prototype._handleDisconnect = function (twitterMsg) {\n  this.emit('disconnect', twitterMsg);\n  this.stop();\n};\n/**\n * Call whenever an http request is about to be made to update\n * our local timestamp (used for Oauth) to be Twitter's server time.\n *\n */\n\n\nStreamingAPIConnection.prototype._setOauthTimestamp = function () {\n  var self = this;\n\n  if (self.reqOpts.oauth) {\n    var oauth_ts = Date.now() + self._twitter_time_minus_local_time_ms;\n\n    self.reqOpts.oauth.timestamp = Math.floor(oauth_ts / 1000).toString();\n  }\n};\n/**\n * Call whenever an http response is received from Twitter,\n * to set our local timestamp offset from Twitter's server time.\n * This is used to set the Oauth timestamp for our next http request\n * to Twitter (by calling _setOauthTimestamp).\n *\n * @param  {http.IncomingResponse} resp   http response received from Twitter.\n */\n\n\nStreamingAPIConnection.prototype._updateOauthTimestampOffsetFromResponse = function (resp) {\n  if (resp && resp.headers && resp.headers.date && new Date(resp.headers.date).toString() !== 'Invalid Date') {\n    var twitterTimeMs = new Date(resp.headers.date).getTime();\n    this._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n  }\n};\n\nmodule.exports = StreamingAPIConnection;","map":{"version":3,"sources":["/Users/kylelong/corkedup/node_modules/twit/lib/streaming-api-connection.js"],"names":["EventEmitter","require","util","helpers","Parser","request","STATUS_CODES_TO_ABORT_ON","StreamingAPIConnection","reqOpts","twitOptions","_twitter_time_minus_local_time_ms","call","inherits","prototype","_resetConnection","removeAllListeners","destroy","response","parser","clearTimeout","_scheduledReconnect","_stopStallAbortTimeout","_resetRetryParams","_connectInterval","_usedFirstReconnect","_startPersistentConnection","self","_setupParser","_resetStallAbortTimeout","_setOauthTimestamp","encoding","post","emit","on","_updateOauthTimestampOffsetFromResponse","indexOf","statusCode","body","chunk","JSON","parse","jsonDecodeError","error","makeTwitError","attachBodyInfoToError","stop","err","twitErr","message","_scheduleReconnect","data","_onClose","bind","start","_stallAbortTimeout","setTimeout","String","charAt","msg","delete","disconnect","_handleDisconnect","limit","scrub_geo","warning","status_withheld","user_withheld","friends","friends_str","direct_message","event","ev","twitterMsg","oauth","oauth_ts","Date","now","timestamp","Math","floor","toString","resp","headers","date","twitterTimeMs","getTime","module","exports"],"mappings":"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","sourcesContent":["\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar helpers = require('./helpers')\nvar Parser = require('./parser');\nvar request = require('request');\n\nvar STATUS_CODES_TO_ABORT_ON = require('./settings').STATUS_CODES_TO_ABORT_ON\n\nvar StreamingAPIConnection = function (reqOpts, twitOptions) {\n  this.reqOpts = reqOpts\n  this.twitOptions = twitOptions\n  this._twitter_time_minus_local_time_ms = 0\n  EventEmitter.call(this)\n}\n\nutil.inherits(StreamingAPIConnection, EventEmitter)\n\n/**\n * Resets the connection.\n * - clears request, response, parser\n * - removes scheduled reconnect handle (if one was scheduled)\n * - stops the stall abort timeout handle (if one was scheduled)\n */\nStreamingAPIConnection.prototype._resetConnection = function () {\n  if (this.request) {\n    // clear our reference to the `request` instance\n    this.request.removeAllListeners();\n    this.request.destroy();\n  }\n\n  if (this.response) {\n    // clear our reference to the http.IncomingMessage instance\n    this.response.removeAllListeners();\n    this.response.destroy();\n  }\n\n  if (this.parser) {\n    this.parser.removeAllListeners()\n  }\n\n  // ensure a scheduled reconnect does not occur (if one was scheduled)\n  // this can happen if we get a close event before .stop() is called\n  clearTimeout(this._scheduledReconnect)\n  delete this._scheduledReconnect\n\n  // clear our stall abort timeout\n  this._stopStallAbortTimeout()\n}\n\n/**\n * Resets the parameters used in determining the next reconnect time\n */\nStreamingAPIConnection.prototype._resetRetryParams = function () {\n  // delay for next reconnection attempt\n  this._connectInterval = 0\n  // flag indicating whether we used a 0-delay reconnect\n  this._usedFirstReconnect = false\n}\n\nStreamingAPIConnection.prototype._startPersistentConnection = function () {\n  var self = this;\n  self._resetConnection();\n  self._setupParser();\n  self._resetStallAbortTimeout();\n  self._setOauthTimestamp();\n  this.reqOpts.encoding = 'utf8'\n  self.request = request.post(this.reqOpts);\n  self.emit('connect', self.request);\n  self.request.on('response', function (response) {\n    self._updateOauthTimestampOffsetFromResponse(response)\n    // reset our reconnection attempt flag so next attempt goes through with 0 delay\n    // if we get a transport-level error\n    self._usedFirstReconnect = false;\n    // start a stall abort timeout handle\n    self._resetStallAbortTimeout();\n    self.response = response\n    if (STATUS_CODES_TO_ABORT_ON.indexOf(self.response.statusCode) !== -1) {\n      // We got a status code telling us we should abort the connection.\n      // Read the body from the response and return an error to the user.\n      var body = '';\n\n      self.request.on('data', function (chunk) {\n        body += chunk;\n      })\n\n      self.request.on('end', function () {\n        try {\n          body = JSON.parse(body)\n        } catch (jsonDecodeError) {\n          // Twitter may send an HTML body\n          // if non-JSON text was returned, we'll just attach it to the error as-is\n        }\n        // surface the error to the user\n        var error = helpers.makeTwitError('Bad Twitter streaming request: ' + self.response.statusCode)\n        error.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(error, body)\n        self.emit('error', error);\n        // stop the stream explicitly so we don't reconnect\n        self.stop()\n        body = null;\n      });\n      self.request.on('error', function (err) {\n        var twitErr = helpers.makeTwitError(err.message);\n        twitErr.statusCode = self.response.statusCode;\n        helpers.attachBodyInfoToError(twitErr, body);\n        self.emit('parser-error', twitErr);\n      });\n    } else if (self.response.statusCode === 420) {\n      // close the connection forcibly so a reconnect is scheduled by `self.onClose()`\n      self._scheduleReconnect();\n    } else {\n      // We got an OK status code - the response should be valid.\n      // Read the body from the response and return to the user.\n      //pass all response data to parser\n      self.request.on('data', function(data) {\n        self._connectInterval = 0\n        self._resetStallAbortTimeout();\n        self.parser.parse(data);\n      })\n\n      self.response.on('close', self._onClose.bind(self))\n      self.response.on('error', function (err) {\n        // expose response errors on twit instance\n        self.emit('error', err);\n      })\n\n      // connected without an error response from Twitter, emit `connected` event\n      // this must be emitted after all its event handlers are bound\n      // so the reference to `self.response` is not interfered-with by the user until it is emitted\n      self.emit('connected', self.response);\n    }\n  });\n  self.request.on('close', self._onClose.bind(self));\n  self.request.on('error', function (err) { self._scheduleReconnect.bind(self) });\n  return self;\n}\n\n/**\n * Handle when the request or response closes.\n * Schedule a reconnect according to Twitter's reconnect guidelines\n *\n */\nStreamingAPIConnection.prototype._onClose = function () {\n  var self = this;\n  self._stopStallAbortTimeout();\n  if (self._scheduledReconnect) {\n    // if we already have a reconnect scheduled, don't schedule another one.\n    // this race condition can happen if the http.ClientRequest and http.IncomingMessage both emit `close`\n    return\n  }\n\n  self._scheduleReconnect();\n}\n\n/**\n * Kick off the http request, and persist the connection\n *\n */\nStreamingAPIConnection.prototype.start = function () {\n  this._resetRetryParams();\n  this._startPersistentConnection();\n  return this;\n}\n\n/**\n * Abort the http request, stop scheduled reconnect (if one was scheduled) and clear state\n *\n */\nStreamingAPIConnection.prototype.stop = function () {\n  // clear connection variables and timeout handles\n  this._resetConnection();\n  this._resetRetryParams();\n  return this;\n}\n\n/**\n * Stop and restart the stall abort timer (called when new data is received)\n *\n * If we go 90s without receiving data from twitter, we abort the request & reconnect.\n */\nStreamingAPIConnection.prototype._resetStallAbortTimeout = function () {\n  var self = this;\n  // stop the previous stall abort timer\n  self._stopStallAbortTimeout();\n  //start a new 90s timeout to trigger a close & reconnect if no data received\n  self._stallAbortTimeout = setTimeout(function () {\n    self._scheduleReconnect()\n  }, 90000);\n  return this;\n}\n\n/**\n * Stop stall timeout\n *\n */\nStreamingAPIConnection.prototype._stopStallAbortTimeout = function () {\n  clearTimeout(this._stallAbortTimeout);\n  // mark the timer as `null` so it is clear via introspection that the timeout is not scheduled\n  delete this._stallAbortTimeout;\n  return this;\n}\n\n/**\n * Computes the next time a reconnect should occur (based on the last HTTP response received)\n * and starts a timeout handle to begin reconnecting after `self._connectInterval` passes.\n *\n * @return {Undefined}\n */\nStreamingAPIConnection.prototype._scheduleReconnect = function () {\n  var self = this;\n  if (self.response && self.response.statusCode === 420) {\n    // we are being rate limited\n    // start with a 1 minute wait and double each attempt\n    if (!self._connectInterval) {\n      self._connectInterval = 60000;\n    } else {\n      self._connectInterval *= 2;\n    }\n  } else if (self.response && String(self.response.statusCode).charAt(0) === '5') {\n    // twitter 5xx errors\n    // start with a 5s wait, double each attempt up to 320s\n    if (!self._connectInterval) {\n      self._connectInterval = 5000;\n    } else if (self._connectInterval < 320000) {\n      self._connectInterval *= 2;\n    } else {\n      self._connectInterval = 320000;\n    }\n  } else {\n    // we did not get an HTTP response from our last connection attempt.\n    // DNS/TCP error, or a stall in the stream (and stall timer closed the connection)\n    if (!self._usedFirstReconnect) {\n      // first reconnection attempt on a valid connection should occur immediately\n      self._connectInterval = 0;\n      self._usedFirstReconnect = true;\n    } else if (self._connectInterval < 16000) {\n      // linearly increase delay by 250ms up to 16s\n      self._connectInterval += 250;\n    } else {\n      // cap out reconnect interval at 16s\n      self._connectInterval = 16000;\n    }\n  }\n\n  // schedule the reconnect\n  self._scheduledReconnect = setTimeout(function () {\n    self._startPersistentConnection();\n  }, self._connectInterval);\n  self.emit('reconnect', self.request, self.response, self._connectInterval);\n}\n\nStreamingAPIConnection.prototype._setupParser = function () {\n  var self = this\n  self.parser = new Parser()\n\n  // handle twitter objects as they come in - emit the generic `message` event\n  // along with the specific event corresponding to the message\n  self.parser.on('element', function (msg) {\n    self.emit('message', msg)\n\n    if      (msg.delete)          { self.emit('delete', msg) }\n    else if (msg.disconnect)      { self._handleDisconnect(msg) }\n    else if (msg.limit)           { self.emit('limit', msg) }\n    else if (msg.scrub_geo)       { self.emit('scrub_geo', msg) }\n    else if (msg.warning)         { self.emit('warning', msg) }\n    else if (msg.status_withheld) { self.emit('status_withheld', msg) }\n    else if (msg.user_withheld)   { self.emit('user_withheld', msg) }\n    else if (msg.friends || msg.friends_str) { self.emit('friends', msg) }\n    else if (msg.direct_message)  { self.emit('direct_message', msg) }\n    else if (msg.event)           {\n      self.emit('user_event', msg)\n      // reference: https://dev.twitter.com/docs/streaming-apis/messages#User_stream_messages\n      var ev = msg.event\n\n      if      (ev === 'blocked')                { self.emit('blocked', msg) }\n      else if (ev === 'unblocked')              { self.emit('unblocked', msg) }\n      else if (ev === 'favorite')               { self.emit('favorite', msg) }\n      else if (ev === 'unfavorite')             { self.emit('unfavorite', msg) }\n      else if (ev === 'follow')                 { self.emit('follow', msg) }\n      else if (ev === 'unfollow')               { self.emit('unfollow', msg) }\n      else if (ev === 'mute')                   { self.emit('mute', msg) }\n      else if (ev === 'unmute')                 { self.emit('unmute', msg) }\n      else if (ev === 'user_update')            { self.emit('user_update', msg) }\n      else if (ev === 'list_created')           { self.emit('list_created', msg) }\n      else if (ev === 'list_destroyed')         { self.emit('list_destroyed', msg) }\n      else if (ev === 'list_updated')           { self.emit('list_updated', msg) }\n      else if (ev === 'list_member_added')      { self.emit('list_member_added', msg) }\n      else if (ev === 'list_member_removed')    { self.emit('list_member_removed', msg) }\n      else if (ev === 'list_user_subscribed')   { self.emit('list_user_subscribed', msg) }\n      else if (ev === 'list_user_unsubscribed') { self.emit('list_user_unsubscribed', msg) }\n      else if (ev === 'quoted_tweet')           { self.emit('quoted_tweet', msg) }\n      else if (ev === 'favorited_retweet')      { self.emit('favorited_retweet', msg) }\n      else if (ev === 'retweeted_retweet')      { self.emit('retweeted_retweet', msg) }\n      else                                      { self.emit('unknown_user_event', msg) }\n    } else                                      { self.emit('tweet', msg) }\n  })\n\n  self.parser.on('error', function (err) {\n    self.emit('parser-error', err)\n  });\n  self.parser.on('connection-limit-exceeded', function (err) {\n    self.emit('error', err);\n  })\n}\n\nStreamingAPIConnection.prototype._handleDisconnect = function (twitterMsg) {\n  this.emit('disconnect', twitterMsg);\n  this.stop();\n}\n\n/**\n * Call whenever an http request is about to be made to update\n * our local timestamp (used for Oauth) to be Twitter's server time.\n *\n */\nStreamingAPIConnection.prototype._setOauthTimestamp = function () {\n  var self = this;\n  if (self.reqOpts.oauth) {\n    var oauth_ts = Date.now() + self._twitter_time_minus_local_time_ms;\n    self.reqOpts.oauth.timestamp = Math.floor(oauth_ts/1000).toString();\n  }\n}\n\n/**\n * Call whenever an http response is received from Twitter,\n * to set our local timestamp offset from Twitter's server time.\n * This is used to set the Oauth timestamp for our next http request\n * to Twitter (by calling _setOauthTimestamp).\n *\n * @param  {http.IncomingResponse} resp   http response received from Twitter.\n */\nStreamingAPIConnection.prototype._updateOauthTimestampOffsetFromResponse = function (resp) {\n  if (resp && resp.headers && resp.headers.date &&\n      new Date(resp.headers.date).toString() !== 'Invalid Date'\n  ) {\n    var twitterTimeMs = new Date(resp.headers.date).getTime()\n    this._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n  }\n}\n\nmodule.exports = StreamingAPIConnection\n"]},"metadata":{},"sourceType":"script"}